[["index.html", "Data: The Mungening Preface", " Data: The Mungening Sara Haman, Miles Tweed, Conor Howlett, Kevin Howlett 2020-11-19 Preface This project was created to fulfil the requirements of the Fall 2020 Data Munging and Exploratory Data Analysis at New College of Florida. The focus of the project was to produce effective visualizations to accompany the exploratory data analysis process. This bookdown is divided so that each step in the process is its own chapter, so that the reader can walk with us through our work flow. In the first chapter, we present an overview of the project and background information on the topic: the card game, Magic the Gathering. In the second chapter, we explain how we gathered the data and why we chose to combine data from multiple sources. In the third, we assess the data quality metrics for the initial data pulls. These are generated both through objective functions and through interrater scoring. In the fourth, we provide theh code used to clean the data. The analysis of the data spans the fifth and sixth chapters. In chapter five, we provide descriptive statistics for the variables of interest. In chapter six, we provide an in-depth examination of several aspects of the data in order to parse out potential relationships of interest. The results of these analysis are discussed throughout the text. The final chapter is the discussion, wherein we summarize the key findings and discuss our personal take-aways. "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction Magic: The Gathering is a collectible card game that has entertained millions since its inception in 1993. Over the past 27 years, there have been hundreds of sets, and tens of thousands of cards printed, each showcasing distinct artworks, attributes and flavor text. Players engage in competitive games using these cards, in a fantastical, strategic battle that tests a players skill, experience and deck-building ability. Subsequently, the long standing popularity of the game has driven up demand for buying, trading and selling cards through card shops and online retailers. Because of this, there are online records for many of these cards and their respective attributes. From a data standpoint, Magic: The Gathering becomes a perfect candidate for some fun, and rewarding exploratory data analysis. "],["data-the-gathering.html", "Chapter 2 Data the Gathering 2.1 2019 Market Data 2.2 2020 Market Data 2.3 Attributes of the Data", " Chapter 2 Data the Gathering Magic the Gathering cards represent a constantly fluctuating ecosystem of distinct cards and market demand. New sets of cards are released multiple times a year, and since the features of the new cards influence how applicable older cards are to the evolving game, the prestige of the cards is constantly changing. The cards also exist in different mediums.There is an online version of Magic the Gathering which accompanies the classical printed card game. The cost of cards between these mediums fluctuates widely, as there is obviously a limited supply of printed cards. Given this information, we thought that it was necessary to examine up-to-date market prices about the cards. This is where we reached an impasse, data collection-wise. We built a scraper that could pull up-to-date market data off of the official Magic the Gathering card market but, because of the data included in the card market, scant information about the cards themselves could be pulled from this site. Detailed card information could be found at MTGJSON, a website dedicated to scraping current information about all of the Magic the Gathering Cards. However, the most recent market data they had was pulled at the end of 2019. Because the card markets fluctuate, we did not believe that data pulled in 2019 could provide us with the most accurate information about current trends between features of Magic the Gathering cards and their prices. So, we decided to use both of these data sets and combine them where we could. The data from the cards was downloaded from MTGJSON in CSV format and cleaned in R. We combined information about the cards and the sets they belong to in order to provide a holistic view of the cards. You can download the data for the cards here and for the sets here. The market data was not immediately accessible in a format that could be transfered directly into R. Because the members of our team were unfamiliar with both web-scraping and JSON-wrangling in R, we utilized Python and MongoDB to access the raw data and transform into usable CSVs. These CSVs were then cleaned and formatted for analysis in R. For the sake of replicability, we have provided links to the annotated Python scripts used to convert the raw data into a format that could be processed in R. The raw data can be downloaded from the following Github Repository: MtG_Group_Project. 2.1 2019 Market Data Click here! 2.2 2020 Market Data Click here! 2.3 Attributes of the Data Data Attributes Guide UUID: skew number of card. Name: The name of the card. Type: The type of card eg: (Creature, Sorcery, Land, etc.) Subtype(s): Applies to Creature Types, denotes what tribes or species a creature belongs to eg: (Merfolk, Goblin, Wizard, etc). Keywords: Ability keywords/commonly adopted game mechanics printed on a card eg: (Flying, Haste, Trample, etc.) Text: Longer description of all game mechanics belonging to the card. Flavor Text: Non-game mechanics based text that provides insight into the lore of the card. Power: The attack attribute belonging to cards with a creature type (an integer). Toughness: The defense/health attribute belonging to cards of the creature type (an integer). Rarity: The commonness or exclusivity of a card eg:(uncommon, rare, mythic rare, common). Converted Mana Cost: The total mana cost to play the card during a game. Generic Mana Cost: How much unspecified mana a card costs. Mana Color: The color(s) of mana that a card costs. Color Mana Cost: The amount of colored mana that a card costs. Set Name: The name of the set in which the card was printed. Release Date: The date of release for a card. MTGO: Magic The Gathering Online card. MTGO Foil: Magic The Gathering Online foil (shiney) card. Paper: The card is physically printed on paper. Paper Foil: Physically printed foil (holographic) . "],["data-quality-metrics.html", "Chapter 3 Data Quality Metrics 3.1 Libararies 3.2 The Functions 3.3 Quality Assessments", " Chapter 3 Data Quality Metrics First, we import the packages that we use in this section and read in the uncleaned data. 3.1 Libararies The libraries loaded in below acts as a list of all of the libraries that will be used in this document. ############################################### ########## ### LIBRARIES ### ########## ############################################### library(tidyverse) library(plotly) library(ggplot2) library(gganimate) library(magick) library(gifski) library(png) library(knitr) library(PerformanceAnalytics) library(ggpubr) library(lubridate) library(ggthemes) library(extrafont) library(tm) library(tidytext) library(textdata) library(gridExtra) library(scales) library(wordcloud) library(reshape2) library(textstem) library(RColorBrewer) library(echarts4r) library(devtools) library(rayshader) library(kableExtra) library(stringi) library(data.table) # SETTING UP FORMATTING kableFormat &lt;- function(dat, caption) { kable(dat, &quot;html&quot;, escape = FALSE, caption = caption) %&gt;% kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;condensed&quot;, &quot;bordered&quot;), full_width = FALSE) } #Reading in the data for the functions c &lt;- read_csv(&quot;cards.csv&quot;) s &lt;- read_csv(&quot;sets.csv&quot;) c19 &lt;- read_csv(&quot;mean_2019_prices.csv&quot;) c20 &lt;- read_csv(&quot;mtgMarketInfo.csv&quot;) 3.2 The Functions CONSISTENT REPRESENTATION con_rep &lt;- function(df){ &quot; A function that quantitatively scores an input data frame on the consistancy of representation data quality metric. Input: df: a data frame Output: con_rep_score: A numeric score on consistency of representation ranging from 1 to 0, where 1 is perfectly consistent representation and 0 is inconsistent representation. &quot; type = vector() for(i in 1:ncol(df)){ col_type &lt;- typeof(df[1,i]) type[i] &lt;- col_type } con_rep_score &lt;- 1 - ((length(unique(type)) - 1)/6) return(con_rep_score) } COMPLETENESS AND EASE OF MANIPULATION data_quality &lt;- function(df){ &quot; A function to quantitatively compute scores for a dataframe on the completeness and ease of manipulation data quality metrics. Input: df: A data frame Output: qualityTable: A table reporting the scores on completeness and ease of manipulation for each column in the input data frame. &quot; # Setting the index value, which will be used to index the column name index &lt;- 1 # Instantiating empty data frames for each of the queries completeness &lt;- data.frame(Completeness=double()) eom &lt;- data.frame(Ease_of_Manipulation=double()) names &lt;- data.frame(ColumnName=character()) # Populating the data frames using a for-loop for (i in df){ # COLLECTING THE NAMES OF EACH COLUMN PASSED col &lt;- colnames(df[index]) # COMPLETENESS # Takes the sum of the total NA, NULL, and NaN values in a column # Divides them by the length of the column # Subtracts this from one, as was suggested by Pipinio, Lee, and Wang # And then rounds to output to the third decimal place c &lt;- 1-(sum(is.na(i) + is.null(i) + is.nan(i))/length(i)) %&gt;% round(digits = 3) # EASE OF MANIPULATION # &quot;Case when&quot; vectorises a series of if/else statements # The function checks the type of the column and then sets the variable, # e, to the corresponding value. e &lt;- case_when( typeof(i) == &quot;logical&quot; ~ 1, typeof(i) == &quot;integer&quot; ~ .9, typeof(i) == &quot;numeric&quot; ~ .8, typeof(i) == &quot;double&quot; ~ .8, typeof(i) == &quot;complex&quot; ~ .7, typeof(i) == &quot;character&quot; ~ .6, typeof(i) == &quot;list&quot; ~ .5, typeof(i) == &quot;raw&quot; ~ 0, TRUE ~ 0) #The index used to collect column names is increased by one index = index + 1 #Appending the output for each column to their respective data frames completeness[nrow(completeness)+1,] &lt;- c eom[nrow(eom)+1,] &lt;- e names[nrow(names)+1,] &lt;- col } #Binding the columns of the three tables into an output table qualityTable &lt;- cbind(names, completeness, eom) return(qualityTable) } 3.3 Quality Assessments We assessed data quality using the metrics outlined in Pipino, Lee, and Wang (2002). For each of these metrics, we provide a brief commentary on how the data fared. Several of the data quality metrics were more pertinent to our analysis, so we provide deeper insight into them. For the subjective measures, each member of the research team produced a subjective score based off of their experience with working with the data. These scores were averaged to produce the score given by the team to the data as a whole. The objective measurements will be preformed on all four of the raw datasets used. Accessibility The data were fairly accessible; the card and set information could be directly downloaded as a CSV. Given our skill set, the JSON file used in the 2019 data was not difficult to gather. Collecting the 2020 market data presented a slight hurtle, but not so far as it made the data inaccessible. All of the raters provided similar scores, which was averaged for a total score of 7. Believability All of these data were originally web-scraped from either official information about the cards and the sets, the process for which is explained in detail on the MTGJSON website, or from the official Magic the Gathering card market itself. All of the raters provided similar scores, which were averaged for a score of 9.3. Conciseness Conciseness varied between data sets; the cards data provided extraneous and duplicate information. However, the other data sets were more streamlined because we had control over which variables we scraped or selected. All raters provided very similar scores for this metric, for an average score of 7. Consistent Representation The output of our objective function can be seen below. cc &lt;- con_rep(c) cs &lt;- con_rep(s) c19c &lt;- con_rep(c19) c20c &lt;- con_rep(c20) con_vector &lt;- c(&quot;Cards&quot; = cc, &quot;Sets&quot; = cs, &quot;Market Data 2019&quot; = c19c, &quot;Market Data 2020&quot; = c20c) con_vector %&gt;% kable(&quot;html&quot;, col.names=&quot;Score&quot;, escape = FALSE, caption = &quot;Consistent Representation Scores&quot;) %&gt;% kable_styling(bootstrap_options = c(&quot;striped&quot;, &quot;condensed&quot;, &quot;bordered&quot;), full_width = FALSE) Table 3.1: Consistent Representation Scores Score Cards 1 Sets 1 Market Data 2019 1 Market Data 2020 1 Completeness and Ease of Manipulation dc &lt;- data_quality(c) %&gt;% kableFormat(&quot;Completeness and EoM for Cards&quot;) dc Table 3.2: Completeness and EoM for Cards ColumnName Completeness Ease_of_Manipulation index 1.000 0.8 id 1.000 0.8 artist 1.000 0.6 asciiName 0.000 1.0 availability 1.000 0.6 borderColor 1.000 0.6 cardKingdomFoilId 0.506 0.8 cardKingdomId 0.762 0.8 colorIdentity 0.890 0.6 colorIndicator 0.000 1.0 colors 0.780 0.6 convertedManaCost 1.000 0.8 duelDeck 0.000 1.0 edhrecRank 0.911 0.8 faceConvertedManaCost 0.000 1.0 faceName 0.000 1.0 flavorName 0.000 1.0 flavorText 0.547 0.6 frameEffects 0.047 0.6 frameVersion 0.998 0.8 hand 0.000 1.0 hasAlternativeDeckLimit 1.000 0.8 hasContentWarning 1.000 0.8 hasFoil 1.000 0.8 hasNonFoil 1.000 0.8 isAlternative 1.000 0.8 isFullArt 1.000 0.8 isOnlineOnly 1.000 0.8 isOversized 1.000 0.8 isPromo 1.000 0.8 isReprint 1.000 0.8 isReserved 1.000 0.8 isStarter 1.000 0.8 isStorySpotlight 1.000 0.8 isTextless 1.000 0.8 isTimeshifted 1.000 0.8 keywords 0.362 0.6 layout 1.000 0.6 leadershipSkills 0.063 0.6 life 0.000 1.0 loyalty 0.014 0.8 manaCost 0.872 0.6 mcmId 0.773 0.8 mcmMetaId 0.691 0.8 mtgArenaId 0.000 1.0 mtgjsonV4Id 1.000 0.6 mtgoFoilId 0.441 0.8 mtgoId 0.567 0.8 multiverseId 0.737 0.8 name 1.000 0.6 number 1.000 0.6 originalReleaseDate 0.000 1.0 originalText 0.722 0.6 originalType 0.737 0.6 otherFaceIds 0.000 1.0 power 0.461 0.6 printings 1.000 0.6 promoTypes 0.102 0.6 purchaseUrls 0.884 0.6 rarity 1.000 0.6 scryfallId 1.000 0.6 scryfallIllustrationId 1.000 0.6 scryfallOracleId 1.000 0.6 setCode 1.000 0.6 side 0.000 1.0 subtypes 0.608 0.6 supertypes 0.134 0.6 tcgplayerProductId 0.878 0.8 text 0.983 0.6 toughness 0.461 0.6 type 1.000 0.6 types 1.000 0.6 uuid 1.000 0.6 variations 0.143 0.6 watermark 0.000 1.0 ds &lt;- data_quality(s) %&gt;% kableFormat(&quot;Completeness and EoM for Sets&quot;) ds Table 3.3: Completeness and EoM for Sets ColumnName Completeness Ease_of_Manipulation index 1.000 0.8 id 1.000 0.8 baseSetSize 1.000 0.8 block 0.461 0.6 booster 0.266 0.6 code 1.000 0.6 isFoilOnly 1.000 0.8 isForeignOnly 1.000 0.8 isNonFoilOnly 1.000 0.8 isOnlineOnly 1.000 0.8 isPartialPreview 1.000 0.8 keyruneCode 1.000 0.6 mcmId 0.398 0.8 mcmName 0.398 0.6 mtgoCode 0.314 0.6 name 1.000 0.6 parentCode 0.211 0.6 releaseDate 1.000 0.8 tcgplayerGroupId 0.507 0.8 totalSetSize 1.000 0.8 type 1.000 0.6 dc19 &lt;- data_quality(c19) %&gt;% kableFormat(&quot;Completeness and EoM for the 2019 Market Data&quot;) dc19 Table 3.4: Completeness and EoM for the 2019 Market Data ColumnName Completeness Ease_of_Manipulation uuid 1 0.6 mtgo 1 0.8 mtgoFoil 1 0.8 paper 1 0.8 paperFoil 1 0.8 dc20 &lt;- data_quality(c20) %&gt;% kableFormat(&quot;Completeness and EoM for the 2020 Market Data&quot;) dc20 Table 3.5: Completeness and EoM for the 2020 Market Data ColumnName Completeness Ease_of_Manipulation Card Name 1.000 0.6 Rarity 1.000 0.6 Serial no. 0.798 0.8 Market Price 1.000 0.6 Buylist Price 1.000 0.6 Listed Median 1.000 0.6 Set Name 1.000 0.6 Reputation As the data was scraped from official sources on the topic, the apparent reputation of the data is presumed to be high. Online research into public opinion on MTGJSON on the official Magic the Gathering Forum and the Magic the Gathering Reddit suggests that it has a very good reputation among data savvy MtG players and is thought to be very useful. The inter-rater scores for this category were very similar, and were considered in conjunction with a score produced for visible public opinion on the data. The reputation score was calculated as 8.75. Timeliness The timeliness of the data is variable. Though the 2019 data was pulled at the end of the year and is relatively recent, respective to other data sets on the internet, was not sufficient for all of our needs. This is why we pulled the 2020 data directly from the live website. The cards and sets data were up to date. The inter-rater scores were again very similar for this category. These data were attributed a timeliness score of 7.33. "],["data-cleaning.html", "Chapter 4 Data Cleaning 4.1 The Cleaning Script", " Chapter 4 Data Cleaning 4.1 The Cleaning Script The script below reads in the csvs needed and, at the end, outputs a merged CSV file containing the card and 2019 prices data joined by applicable columns. The inline comments explain what the script is doing at each stage. This data will later be compared with the 2020 price data, which is fundamentally a very different data set, though it has some variables that can be directly compared. This will be expanded on during the analysis. ############################################### ########## ### CARDS ### ########## ############################################### # READING IN THE DATA cardsRaw &lt;- read_csv(&quot;cards.csv&quot;, col_names = TRUE) # head(cardsRaw) #SELECTING RELEVANT COLUMNS keepCols &lt;- c(&quot;artist&quot;,&quot;uuid&quot;, &quot;mcmId&quot;, &quot;mtgjsonV4Id&quot;, &quot;multiverseId&quot;, &quot;name&quot;, &quot;artist&quot;, &quot;type&quot;, &quot;subtypes&quot;, &quot;supertypes&quot;, &quot;manaCost&quot;, &quot;convertedManaCost&quot;, &quot;keywords&quot;, &quot;text&quot;, &quot;flavorText&quot;, &quot;power&quot;, &quot;toughness&quot;, &quot;rarity&quot;, &quot;edhrecRank&quot;, &quot;isOnlineOnly&quot;) cards &lt;- select_(cardsRaw, .dots = keepCols) # head(cards) # CLEANING TYPES cards$type &lt;- word(cards$type, 1, sep=&quot; &quot;) # REMOVING SPECIAL CHARACTERS FROM THE TEXT VARIABLES cards$text &lt;- str_replace_all(cards$text, &quot;[[:punct:]]&quot;, &quot;&quot;) cards$flavorText &lt;- str_replace_all(cards$flavorText, &quot;[[:punct:]]&quot;, &quot;&quot;) # CLEANING THE MANA CLUSTERF**K # If the manaCost is NA, replace it with Z so that it can be processed by str_detect. Converted back later. cards$manaCost &lt;- replace_na(cards$manaCost, &quot;Z&quot;) #Removing the brackets cards$manaCost = str_replace_all(cards$manaCost, &quot;[{}]&quot;, &quot;&quot;) #Creating a variable to hold the &#39;generic&#39; mana cost cards$genericManaCost &lt;- NA # Counting the generic mana cost for each row # If X is included in the data, that means the # of generic mana is determined by the game environment c = 1 for (i in cards$manaCost){ a = str_detect(i, &quot;.*[0-9].*&quot;) if ( a == TRUE){ if (substr(i, start = 1, stop = 1) == &#39;X&#39;){ cards$genericManaCost[c] &lt;- &quot;Determined in Game&quot; } else { cards$genericManaCost[c] &lt;- substr(i, start = 1, stop = 1) } } else { cards$genericManaCost[c] &lt;- &quot;No Generic Cost&quot; } c = c + 1 } # Cleaning manaCost to remove data pertaining to generic mana cards$manaCost &lt;- str_replace_all(cards$manaCost, &#39;X&#39;, &#39;&#39;) %&gt;% removeNumbers() # HANDLING CARD COLOR # Creating the color variable cards$manaColor &lt;- NA # Splitting the letters so that they can be compared, these are put in a temporary variable cards$temp &lt;- str_split(cards$manaCost, &quot;&quot;) # Identifying the mana color # If the card deals with more than one type of mana, it is assigned to the category &quot;Multiple Types&quot; c = 1 for (i in cards$temp){ if (length(i) &lt;= 1){ cards$manaColor[c] &lt;- i[1] } else if(i[1] == i[2]) { cards$manaColor[c] &lt;- i[1] } else { cards$manaColor[c] &lt;- &quot;Multiple Types&quot; } c = c+1 } # Colored mana cost is calculated by simply taking the length of the manaCost string (i.e., WWW would be 3) cards$colorManaCost &lt;- nchar(cards$manaCost) #Handling NA&#39;s cards$manaColor[is.na(cards$manaColor)] &lt;- &quot;No Color&quot; cards$manaColor[cards$manaColor == &#39;Z&#39;] &lt;- &quot;No Color&quot; cards$colorManaCost &lt;- ifelse(cards$manaColor == &quot;No Color&quot;, &quot;No Color Cost&quot;, cards$colorManaCost) #Removing the depreciated columns cards &lt;- subset(cards, select = -c(temp, manaCost)) ############################################### ########## ### SETS ### ########## ############################################### # READING IN THE DATA setsRaw &lt;- read_csv(&quot;sets.csv&quot;, col_names = TRUE) # head(setsRaw) #SELECTING RELEVANT COLUMNS keepColsSets &lt;- c(&quot;mcmId&quot;, &quot;name&quot;, &quot;releaseDate&quot;) sets &lt;- select_(setsRaw, .dots = keepColsSets) %&gt;% rename( &quot;setName&quot; = &quot;name&quot; ) sets &lt;- sets[!is.na(sets$mcmId), ] ############################################### ########## ### JOIN ### ########## ############################################### # Joining cards with sets on MCM ID mtg &lt;- left_join(cards, sets, by = &quot;mcmId&quot;) # head(mtg) # sum(is.na(mtg$releaseDate)) ############################################### ########## ## PRICES ## ########## ############################################### # READING IN THE DATA prices19 &lt;- read_csv(&quot;mean_2019_prices.csv&quot;, col_names = TRUE) mtg_prices19 &lt;- inner_join(mtg, prices19, by = c(&quot;mtgjsonV4Id&quot; = &quot;uuid&quot;)) columnOrder &lt;- c(&quot;uuid&quot;, &quot;mtgjsonV4Id&quot;, &quot;name&quot;, &quot;artist&quot;, &quot;type&quot;, &quot;subtypes&quot;, &quot;supertypes&quot;, &quot;keywords&quot;, &quot;text&quot;, &quot;flavorText&quot;, &quot;power&quot;, &quot;toughness&quot;, &quot;rarity&quot;, &quot;edhrecRank&quot;, &quot;isOnlineOnly&quot;, &quot;convertedManaCost&quot;, &quot;genericManaCost&quot;, &quot;manaColor&quot;, &quot;colorManaCost&quot;, &quot;setName&quot;, &quot;releaseDate&quot;, &quot;mtgo&quot;, &quot;mtgoFoil&quot;, &quot;paper&quot;, &quot;paperFoil&quot;) mtg_prices19 &lt;- mtg_prices19[, columnOrder] # write.csv(mtg_prices19, &quot;cleanData_New.csv&quot;) 4.1.1 Post-Download Formatting Because certain facets of the data cannot be retained when the data is formatted as a .CSV, we produced a post-download formatting block which can be copied and pasted in at the beginning of any R file using the above CSV to convert the data to the ideal format for manipulation. # TOKENIZING SUBTYPES mtg$subtypes &lt;- str_split(mtg$subtypes, &quot;,&quot;) # TOKENIZING KEYWORDS mtg$keywords &lt;- str_split(mtg$keywords, &quot;,&quot;) # TURNING RARITY INTO A FACTOR mtg$rarity &lt;- factor(mtg$rarity, levels = c(&quot;common&quot;, &quot;uncommon&quot;, &quot;rare&quot;, &quot;mythic&quot;), ordered = TRUE) #FORMATTING POWER AND TOUGHNESS CORRECTLY # forces some to numeric, however upon investigation the cards turned to NA&#39;s are &#39;booster&#39; cards, which are like spell cards # these cards can be identified by their key words mtg$power &lt;- as.numeric(mtg$power) mtg$toughness &lt;- as.numeric(mtg$toughness) head(mtg, 5) %&gt;% kableFormat(&quot;Clean Magic the Gathering Data&quot;) Table 4.1: Clean Magic the Gathering Data artist uuid mcmId mtgjsonV4Id multiverseId name type subtypes supertypes convertedManaCost keywords text flavorText power toughness rarity edhrecRank isOnlineOnly genericManaCost manaColor colorManaCost setName releaseDate Rebecca Guay 38513fa0-ea83-5642-8ecd-4f0b3daa6768 16413 1669af17-d287-5094-b005-4b143441442f 130483 Abundance Enchantment NA NA 4 NA If you would draw a card you may instead choose land or nonland and reveal cards from the top of your library until you reveal a card of the chosen kind Put that card into your hand and put all other cards revealed this way on the bottom of your library in any order NA NA NA rare 1099 0 2 G 2 NA NA Stephen Daniele b8a68840-4044-52c0-a14e-0a1c630ba42c 16227 047d5499-a21c-5f5c-9679-1599fcaf9815 132072 Academy Researchers Creature Human , Wizard NA 3 NA When Academy Researchers enters the battlefield you may put an Aura card from your hand onto the battlefield attached to Academy Researchers They brandish their latest theories as warriors would wield weapons 2 2 uncommon 12014 0 1 U 2 NA NA John Avon 11727081-4070-56db-8162-b970dd7f94bc 16511 ee19938c-4007-58f1-8904-fae28007b422 129458 Adarkar Wastes Land NA NA 0 NA T Add C T Add W or U Adarkar Wastes deals 1 damage to you NA NA NA rare 597 0 No Generic Cost No Color No Color Cost NA NA Roger Raupp 9acf4d13-d68f-5fec-93b4-caf0a14725a5 16289 8774e18f-3752-5c06-af94-5da3960da9ed 135206 Afflict Instant NA NA 3 NA Target creature gets 11 until end of turn Draw a card One rarely notices a heartbeat save when it is stolen NA NA common 16583 0 2 B 1 NA NA Christopher Moeller 0dea6b2e-25bc-5c31-aa1b-a7690af6b853 16414 4e875bca-0c52-5d60-889d-1db67e261737 130525 Aggressive Urge Instant NA NA 2 NA Target creature gets +1+1 until end of turn Draw a card The power of the wild concentrated in a single charge NA NA common 10248 0 1 G 1 NA NA "],["descriptive-statistics.html", "Chapter 5 Descriptive Statistics 5.1 Set-up 5.2 Descriptives 5.3 Distribution of Prices 5.4 Correlation of Numerical Data 5.5 Printing type 5.6 Frame Version 5.7 Release Date 5.8 Rarity", " Chapter 5 Descriptive Statistics 5.1 Set-up # cleaned Card data with price data cards &lt;- read_csv(&#39;AllCardsAlt.csv&#39;) ## Parsed with column specification: ## cols( ## .default = col_character(), ## X1 = col_double(), ## convertedManaCost = col_double(), ## edhrecRank = col_double(), ## frameVersion = col_double(), ## hasFoil = col_logical(), ## hasNonFoil = col_logical(), ## isMtgo = col_logical(), ## isPaper = col_logical(), ## isReprint = col_logical(), ## releaseDate = col_date(format = &quot;&quot;), ## isStarter = col_logical(), ## mtgo = col_double(), ## mtgoFoil = col_double(), ## paper = col_double(), ## paperFoil = col_double() ## ) ## See spec(...) for full column specifications. cards &lt;- tibble(cards) cards &lt;- cards[,-1] cards &lt;- cards %&gt;% mutate(&#39;year&#39; = format(cards$releaseDate, format=&#39;%Y&#39;)) cards$year &lt;- cards$year %&gt;% as.character() cards$frameVersion &lt;- cards$frameVersion %&gt;% as.character() 5.2 Descriptives The following table gives an overview of the numerical variables. The variable convertedManaCost is an aspect of the card that is used in play. The variable edhrecRank is a score given to the card by the website EDHREC which provides card information. The last four variables (mtgo, mtgoFoil, paper, and paperFoil) are different printing of the cards. Mtgo and mtgoFoil are digital versions of the cards whereas paper and paperFoil are physical. The distribution is heavily skewed with a majority of the cards in the low price range with a few extremely high prices outliers. convertedManaCost edhrecRank mtgo mtgoFoil paper paperFoil minimum 0.000000e+00 1.000 0.0000000 0.0000000 0.000000e+00 0.000000 lower-hinge 2.000000e+00 2759.000 0.0000000 0.0000000 3.000000e-02 0.000000 median 3.000000e+00 7445.500 0.0100000 0.0100000 1.400000e-01 0.120000 upper-hinge 4.000000e+00 13105.000 0.0300000 0.0300000 4.521053e-01 0.900000 maximum 1.000000e+06 19281.000 345.0200000 100.6400000 1.499900e+04 4159.831579 mean 4.469705e+01 8113.562 0.2491689 0.3159343 6.993864e+00 3.626086 standard deviation 6.463173e+03 5822.852 2.5891530 1.8520141 1.297658e+02 27.271963 5.3 Distribution of Prices Every type of card printing followed the same type of right skewed price distribution. The vast majority of the cards are priced in the lower range with some exreme outliers. p1 &lt;- cards[,&#39;paper&#39;] %&gt;% ggplot() + geom_histogram(aes(x=paper, fill=I(&#39;darkgreen&#39;)), bins = 10) + labs(title = &#39;Price Distribution of Paper&#39;) p2 &lt;- cards[,&#39;paperFoil&#39;] %&gt;% ggplot() + geom_histogram(aes(x=paperFoil, fill=I(&#39;darkgreen&#39;)), bins = 10) + labs(title = &#39;Price Distribution of Paper Foil&#39;) p3 &lt;- cards[,&#39;mtgo&#39;] %&gt;% ggplot() + geom_histogram(aes(x=mtgo, fill=I(&#39;darkgreen&#39;)), bins = 10) + labs(title = &#39;Price Distribution of Digital&#39;) p4 &lt;- cards[,&#39;mtgoFoil&#39;] %&gt;% ggplot() + geom_histogram(aes(x=mtgoFoil, fill=I(&#39;darkgreen&#39;)), bins = 10) + labs(title = &#39;Price Distribution of Digital Foil&#39;) ggarrange(p1,p2,p3,p4,nrow=2,ncol=2) The following displays the distribution at the lower range of price (&lt;$10). p1 &lt;- cards[,&#39;paper&#39;] %&gt;% filter(paper &lt; 10) %&gt;% ggplot() + geom_histogram(aes(x=paper, fill=I(&#39;darkgreen&#39;)), bins=30) + labs(title = &#39;Price Distribution of Paper&#39;) p2 &lt;- cards[,&#39;paperFoil&#39;] %&gt;% filter(paperFoil &lt; 10) %&gt;% ggplot() + geom_histogram(aes(x=paperFoil, fill=I(&#39;darkgreen&#39;)), bins=30) + labs(title = &#39;Price Distribution of Paper Foil&#39;) p3 &lt;- cards[,&#39;mtgo&#39;] %&gt;% filter(mtgo &lt; 10) %&gt;% ggplot() + geom_histogram(aes(x=mtgo, fill=I(&#39;darkgreen&#39;)), bins=30) + labs(title = &#39;Price Distribution of Digital&#39;) p4 &lt;- cards[,&#39;mtgoFoil&#39;] %&gt;% filter(mtgoFoil &lt; 10) %&gt;% ggplot() + geom_histogram(aes(x=mtgoFoil, fill=I(&#39;darkgreen&#39;)), bins=30) + labs(title = &#39;Price Distribution of Digital Foil&#39;) ggarrange(p1,p2,p3,p4,nrow=2,ncol=2) 5.4 Correlation of Numerical Data None of the numerical categories show much correlation with the price variables. cards %&gt;% sample_n(5000) %&gt;% select_if(is.numeric) %&gt;% chart.Correlation() 5.5 Printing type The following is a comparison of how cards price in one type of printing corresponds to its price in another type of printing. Often, higher prices in one type of printing correspond to higher prices in another. q1 &lt;- cards[,c(&quot;name&quot;,&quot;paper&quot;,&quot;paperFoil&quot;)] %&gt;% filter(paper &gt; 0 &amp; paperFoil &gt; 0)%&gt;% group_by(name) %&gt;% ggplot(aes(x = paper, y = paperFoil)) + geom_point() + geom_smooth() q2 &lt;- cards[,c(&quot;name&quot;,&quot;paper&quot;,&quot;mtgo&quot;)] %&gt;% filter(paper &gt; 0 &amp; mtgo &gt; 0)%&gt;% group_by(name) %&gt;% ggplot(aes(x = paper, y = mtgo)) + geom_point() + geom_smooth() q3 &lt;- cards[,c(&quot;name&quot;,&quot;paperFoil&quot;,&quot;mtgoFoil&quot;)] %&gt;% filter(paperFoil &gt; 0 &amp; mtgoFoil&gt;0) %&gt;% group_by(name) %&gt;% ggplot(aes(x = paperFoil, y = mtgoFoil)) + geom_point() + geom_smooth() q4 &lt;- cards[,c(&quot;name&quot;,&quot;mtgo&quot;,&quot;mtgoFoil&quot;)] %&gt;% filter(mtgo &gt; 0 &amp; mtgoFoil&gt;0) %&gt;% group_by(name) %&gt;% ggplot(aes(x = mtgo, y = mtgoFoil)) + geom_point() + geom_smooth() q5 &lt;- cards[,c(&quot;name&quot;,&quot;paper&quot;,&quot;mtgoFoil&quot;)] %&gt;% filter(paper &gt; 0 &amp; mtgoFoil&gt;0) %&gt;% group_by(name) %&gt;% ggplot(aes(x = paper, y = mtgoFoil)) + geom_point() + geom_smooth() q6 &lt;- cards[,c(&quot;name&quot;,&quot;mtgo&quot;,&quot;paperFoil&quot;)] %&gt;% filter(mtgo &gt; 0 &amp; paperFoil&gt;0) %&gt;% group_by(name) %&gt;% ggplot(aes(x = mtgo, y = paperFoil)) + geom_point() + geom_smooth() ggarrange(q1,q2,q3,q4,q5,q6,ncol=2,nrow=3) ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; 5.6 Frame Version The frame version variable describes the style of the border around the card and is named by year. The earliest version of the frame is dominated by the paper card type. The later frame versions show that physical cards fetch higher prices on average with the foil versions fetch the highest price. # prices by frameVersion (Version of the card frame style.) cards[,c(&quot;frameVersion&quot;,&quot;mtgo&quot;,&quot;mtgoFoil&quot;,&quot;paper&quot;,&quot;paperFoil&quot;)] %&gt;% gather(mtgo,mtgoFoil,paper,paperFoil, key=&#39;paperType&#39;, value=&#39;price&#39;, na.rm = T) %&gt;% filter(!is.na(frameVersion)) %&gt;% group_by(frameVersion,paperType) %&gt;% summarise_at(&#39;price&#39;,mean,rm.na = T) %&gt;% ggplot(aes(x = frameVersion, y = price, fill=paperType)) + geom_col(position=&#39;dodge&#39;) + labs(title=&#39;Mean Prices By Frame Version&#39;, fill=&#39;Printing&#39;) + xlab(&#39;Frame Version&#39;) 5.7 Release Date The cards with the earliest release date fetch the highest prices by far followed by the cards released in 2001. The graph of the proportion of printings shows that foil cards begin to dominate the field around 1999. Interestingly, the 2001 release year had the greatest proportion of foil cards which may factor into the reason why that year had the second highest average price #mean price by release date and printing type cards %&gt;% gather(mtgo,mtgoFoil,paper,paperFoil, key=&#39;paperType&#39;, value=&#39;price&#39;) %&gt;% group_by(year, paperType) %&gt;% summarise_at(&#39;price&#39;,mean,rm.na=T) %&gt;% ggplot(aes(x = year, y = price, fill=paperType)) + geom_col() + theme(axis.text.x = element_text(angle = 45)) + labs(title=&#39;Mean Price By Year And Printing&#39;, fill=&#39;Printing&#39;) #mean price by release date and printing type excluding the outlier cards %&gt;% gather(mtgo,mtgoFoil,paper,paperFoil, key=&#39;paperType&#39;, value=&#39;price&#39;) %&gt;% group_by(year, paperType) %&gt;% filter(year != &#39;1993&#39;) %&gt;% summarise_at(&#39;price&#39;,mean,rm.na=T) %&gt;% ggplot(aes(x = year, y = price, fill=paperType)) + geom_col() + theme(axis.text.x = element_text(angle = 45)) + labs(title=&#39;Mean Price By Year (&gt;1993) And Printing&#39;, fill=&#39;Printing&#39;) # proportion of mean price by release date and printing type cards %&gt;% gather(mtgo,mtgoFoil,paper,paperFoil, key=&#39;paperType&#39;, value=&#39;price&#39;) %&gt;% group_by(year, paperType) %&gt;% summarise_at(&#39;price&#39;,mean,rm.na=T) %&gt;% ggplot(aes(x = year, y = price, fill=paperType)) + geom_col(position=&#39;fill&#39;) + theme(axis.text.x = element_text(angle = 45)) + labs(title=&#39;Proportion of Average Price By Year And Printing&#39;, fill=&#39;Printing&#39;) 5.8 Rarity In the plot of mean price by rarity, the physical cards fetch a higher price than the digital versions. The mythic paper cards with foil fetch the highest price on average followed by the rare paper cards. # rarity vs price cards[,c(&quot;rarity&quot;,&quot;mtgo&quot;,&quot;mtgoFoil&quot;,&quot;paper&quot;,&quot;paperFoil&quot;)] %&gt;% gather(mtgo,mtgoFoil,paper,paperFoil, key=&#39;paperType&#39;, value=&#39;price&#39;, na.rm = T) %&gt;% group_by(rarity,paperType) %&gt;% summarise_at(&#39;price&#39;,mean,rm.na = T) %&gt;% plot_ly( x = ~rarity, y = ~price, color = ~paperType, type =&#39;bar&#39;, mode =&#39;marker&#39; ) %&gt;% layout( title = list(text = &#39;Mean price by rarity and card type&#39;, x=0.02) ) However, the rare physical cards fetched the highest prices overall by far. # rarity vs price cards[,c(&quot;rarity&quot;,&quot;mtgo&quot;,&quot;mtgoFoil&quot;,&quot;paper&quot;,&quot;paperFoil&quot;)] %&gt;% gather(mtgo,mtgoFoil,paper,paperFoil, key=&#39;paperType&#39;, value=&#39;price&#39;, na.rm = T) %&gt;% group_by(rarity,paperType) %&gt;% summarise_at(&#39;price&#39;,max,rm.na = T) %&gt;% plot_ly( x = ~rarity, y = ~price, color = ~paperType, type =&#39;bar&#39;, mode =&#39;marker&#39; ) %&gt;% layout( title = list(text = &#39;Maximum price by rarity and card type&#39;, x=0.02) ) "],["feature-analysis.html", "Chapter 6 Feature Analysis 6.1 Prices 6.2 Artist Influence 6.3 Game Mechanics", " Chapter 6 Feature Analysis The code for the analysis and occassional brief commentary is included below. The process of the exploration is expanded on in our verbal project report. #READING IN THE DATA #MTG Data with 2019 Market mtg &lt;- read_csv(&quot;cleanData_New.csv&quot;, col_names = TRUE) #MTG Data with 2019 Market for use in text cmtg &lt;- mtg[,-1] #MTG Data with 2020 Market marketDf &lt;- read_csv(&quot;mtgMarketInfo.csv&quot;, col_names = TRUE) # TOKENIZING SUBTYPES mtg$subtypes &lt;- str_split(mtg$subtypes, &quot;,&quot;) # TOKENIZING KEYWORDS mtg$keywords &lt;- str_split(mtg$keywords, &quot;,&quot;) # TURNING RARITY INTO A FACTOR mtg$rarity &lt;- factor(mtg$rarity, levels = c(&quot;common&quot;, &quot;uncommon&quot;, &quot;rare&quot;, &quot;mythic&quot;), ordered = TRUE) #FORMATTING POWER AND TOUGHNESS CORRECTLY # forces some to numeric, however upon investigation the cards turned to NA&#39;s are &#39;booster&#39; cards, which are like spell cards # these cards can be identified by their key words mtg$power &lt;- as.numeric(mtg$power) mtg$toughness &lt;- as.numeric(mtg$toughness) 6.1 Prices marketDf$Market.Price &lt;- as.numeric(gsub(&quot;\\\\$&quot;, &quot;&quot;, marketDf$`Market Price`)) marketDf$Listed.Median &lt;- as.numeric(gsub(&quot;\\\\$&quot;, &quot;&quot;, marketDf$`Listed Median`)) marketDf$Card.Name &lt;- marketDf$`Card Name` marketDf$Set.Name &lt;- marketDf$`Set Name` mergedDf &lt;- dplyr::left_join(marketDf, mtg, by=c(&quot;Card.Name&quot; = &quot;name&quot;)) mergedDf$releaseDate &lt;- as.Date(mergedDf$releaseDate) # Group by both rarity and card &quot;type&quot; # Averaged market prices of cards in each of these groups typeDf &lt;- aggregate( Market.Price ~ rarity+type, mergedDf, mean ) # Histogram of average market price by card type (i.e. land, creature, etc.) fig &lt;- typeDf %&gt;% plot_ly( type=&#39;histogram&#39;, nbinsx = 40, x=~Market.Price, bingroup=1, color = ~rarity) %&gt;% layout(title = &#39;Average Market Price by Card Type&#39;, xaxis = list(title = &#39;Avg Market Price [USD]&#39;,range = c(-3, 65))) fig # Boxplot average market price by card type (i.e. land, creature, etc.) typeDf %&gt;% plot_ly() %&gt;% add_trace(x = ~as.numeric(rarity),y = ~Market.Price, color = ~rarity, type = &quot;box&quot;, hoverinfo = &#39;name+y&#39;) %&gt;% add_markers(x = ~jitter(as.numeric(rarity)), y = ~Market.Price, color = ~rarity, marker = list(size = 6), hoverinfo = &quot;text&quot;, text = ~paste0(&quot;Type: &quot;,type, &quot;&lt;br&gt;Rarity: &quot;,rarity, &quot;&lt;br&gt;Avg Price: &quot;,round(Market.Price,2)), showlegend = FALSE) %&gt;% layout(legend = list(orientation = &quot;h&quot;, x =0.6, xanchor = &quot;center&quot;, y = 1, yanchor = &quot;bottom&quot; ), xaxis = list(title = &quot;Rarity&quot;, showticklabels = FALSE), yaxis = list(title = &quot;Avg Market Price [USD]&quot;, showticklabels = FALSE), title = list(text = &#39;Price by Card Type&#39;, x = 0.08)) setDf &lt;- aggregate( Market.Price ~ rarity+Set.Name, mergedDf, mean ) # Histogram of average market price by card set (i.e. Alpha Edition, Arabian Nights, etc.) fig &lt;- setDf %&gt;% plot_ly( type=&#39;histogram&#39;, nbinsx = 30, x=~Market.Price, bingroup=1, color = ~rarity) %&gt;% layout(title = &#39;Average Market Price by Card Set&#39;, xaxis = list(title = &#39;Avg Market Price [USD]&#39;,range = c(-10, 140))) fig # Boxplot average market price by card set (i.e. Beta Edition, Alpha Edition, etc.) setDf %&gt;% plot_ly() %&gt;% add_trace(x = ~as.numeric(rarity),y = ~Market.Price, color = ~rarity, type = &quot;box&quot;, hoverinfo = &#39;name+y&#39;) %&gt;% add_markers(x = ~jitter(as.numeric(rarity)), y = ~Market.Price, color = ~rarity, marker = list(size = 6), hoverinfo = &quot;text&quot;, text = ~paste0(&quot;Set: &quot;,Set.Name, &quot;&lt;br&gt;Rarity: &quot;,rarity, &quot;&lt;br&gt;Avg Price: &quot;,round(Market.Price,2)), showlegend = FALSE) %&gt;% layout(legend = list(orientation = &quot;h&quot;, x =0.6, xanchor = &quot;center&quot;, y = 1, yanchor = &quot;bottom&quot; ), xaxis = list(title = &quot;Rarity&quot;, showticklabels = FALSE), yaxis = list(title = &quot;Avg Market Price [USD]&quot;, showticklabels = FALSE), title = list(text = &#39;Price by Card Set&#39;, x = 0.08)) # Create new attribute of summed power and toughness mergedDf$power.toughness &lt;- mergedDf$power + mergedDf$toughness # The next four plots (arranged with ggarrange) investigate the relationship # of market price vs toughness, mana cost, and power power.scatter &lt;- mergedDf %&gt;% ggplot(.,aes(y = Market.Price, x = power, color = rarity)) + geom_point()+ylab(&#39;Market Price&#39;)+xlab(&#39;Power&#39;)+ylim(0,610)+ ggtitle(&#39;Price v. Power&#39;)+theme(plot.title = element_text(hjust = 0.5))+theme(legend.position=&quot;none&quot;)+theme(panel.background = element_blank()) toughness.scatter &lt;- mergedDf %&gt;% ggplot(.,aes(y = Market.Price, x = toughness, color = rarity)) + geom_point()+ylab(&#39;Market Price&#39;)+xlab(&#39;Toughness&#39;)+ylim(0,610)+ ggtitle(&#39;Price v. Toughness&#39;)+theme(plot.title = element_text(hjust = 0.5)) + theme(legend.position=&quot;none&quot;)+theme(panel.background = element_blank()) mana.scatter &lt;- subset(mergedDf, mergedDf$convertedManaCost != max(mergedDf$convertedManaCost, na.rm=T)) %&gt;% ggplot(.,aes(y = Market.Price, x = convertedManaCost, color = rarity)) + geom_point()+ylab(&#39;Market Price&#39;)+xlab(&#39;Mana Cost&#39;)+ylim(0,610)+ ggtitle(&#39;Price v. Mana Cost&#39;)+theme(plot.title = element_text(hjust = 0.5)) + theme(legend.position=&quot;none&quot;)+theme(panel.background = element_blank()) net.scatter &lt;- mergedDf %&gt;% ggplot(.,aes(y = Market.Price, x = power.toughness, color = rarity)) + geom_point()+ylab(&#39;Market Price&#39;)+xlab(&#39;Power + Toughness&#39;)+ylim(0,610)+ ggtitle(&#39;Price v. Power + Toughness&#39;)+theme(plot.title = element_text(hjust = 0.5))+theme(panel.background = element_blank()) ggarrange(power.scatter, toughness.scatter, mana.scatter, net.scatter) # 3D scatter plot of power, toughness, mana cost (w/ color mapped to rarity) # Shows linear relationship between power, toughness, and mana fig &lt;- plot_ly(mergedDf, x = ~power, y = ~toughness, z = ~convertedManaCost, color = ~rarity) fig &lt;- fig %&gt;% add_markers(hoverinfo = &quot;text&quot;, text = ~paste0(&quot;Power: &quot;,power, &quot;&lt;br&gt;Toughness: &quot;,toughness, &quot;&lt;br&gt;Mana Cost: &quot;,convertedManaCost )) fig &lt;- fig %&gt;% layout(scene = list(xaxis = list(title = &#39;Power&#39;), yaxis = list(title = &#39;Toughness&#39;), zaxis = list(title = &#39;Mana Cost&#39;)), title = list(text = &#39;Mana Cost v Power/Toughness&#39;)) fig 6.2 Artist Influence # Group by both rarity and card artist # Averaged market prices of cards in each of these groups mergedDf$artist &lt;- str_replace_all(mergedDf$artist, &quot;[^[:alnum:]]&quot;, &quot; &quot;) artistDf &lt;- aggregate( Market.Price ~ rarity+artist, mergedDf, mean ) # Histogram of artists&#39; average card selling price fig &lt;- artistDf %&gt;% plot_ly( type=&#39;histogram&#39;, nbinsx = 30, x=~Market.Price, bingroup=1, color = ~rarity) %&gt;% layout(title = &#39;Average Market Price by Artist&#39;, xaxis = list(title = &#39;Avg Market Price [USD]&#39;,range = c(-10, 135))) fig # Boxplot of artists&#39; selling prices artistDf %&gt;% plot_ly() %&gt;% add_trace(x = ~as.numeric(rarity),y = ~Market.Price, color = ~rarity, type = &quot;box&quot;, hoverinfo = &#39;name+y&#39;) %&gt;% add_markers(x = ~jitter(as.numeric(rarity)), y = ~Market.Price, color = ~rarity, marker = list(size = 6), hoverinfo = &quot;text&quot;, text = ~paste0(&quot;Artist :&quot;, artist, &quot;&lt;br&gt;Rarity: &quot;,rarity, &quot;&lt;br&gt;Avg Price: &quot;,round(Market.Price,2)), showlegend = FALSE) %&gt;% layout(legend = list(orientation = &quot;h&quot;, x =0.6, xanchor = &quot;center&quot;, y = 1, yanchor = &quot;bottom&quot; ), xaxis = list(title = &quot;Rarity&quot;, showticklabels = FALSE), yaxis = list(title = &quot;Avg Market Price [USD]&quot;, showticklabels = FALSE), title = list(text = &#39;Price by Card Artist&#39;, x = 0.08)) 6.2.1 Hall of Fame The following artist have made art for cards that sold for over $1000. # artist vs price cards[,c(&quot;artist&quot;,&quot;mtgo&quot;,&quot;mtgoFoil&quot;,&quot;paper&quot;,&quot;paperFoil&quot;)] %&gt;% gather(mtgo,mtgoFoil,paper,paperFoil, key=&#39;paperType&#39;, value=&#39;price&#39;, na.rm = T) %&gt;% filter(!is.na(artist) &amp; price &gt;= 1000) %&gt;% ggplot(aes(x = artist, y = price, fill=I(&#39;blueviolet&#39;))) + geom_col(position=&#39;dodge&#39;) + theme(axis.text.x = element_text(angle = 90))+ geom_hline(aes(yintercept=1000),linetype=2) + geom_text(aes(1,1000,label = 1000, vjust = -1)) + labs(title = &#39;Artists&#39;, caption=&#39;Greater than $1000&#39;) + xlab(&#39;Artist&#39;) + ylab(&#39;Price (USD)&#39;) 6.3 Game Mechanics #the card data read from csv, stored as dataframe mtg &lt;- read.csv(&#39;cleanData_New.csv&#39;, header = T) mtg &lt;- as.data.frame(mtg) #converting string data to numeric mtg[,&#39;power&#39;] &lt;- as.numeric(mtg[,&#39;power&#39;]) ## Warning: NAs introduced by coercion mtg[,&#39;toughness&#39;] &lt;- as.numeric(mtg[,&#39;toughness&#39;]) ## Warning: NAs introduced by coercion #filtering the data to remove NA&#39;s and outliers, aggregating toughness/power into &quot;stats&quot; mtg.0 &lt;- mtg %&gt;% replace_na(list(toughness = 0, power = 0)) %&gt;% mutate(stats = power + toughness) %&gt;% filter(convertedManaCost &lt; 100) #fitting linear regression line fit &lt;- lm(convertedManaCost ~ stats, data=mtg.0) #creating plot fig &lt;- plot_ly(data = mtg.0) %&gt;% add_markers(x = ~stats, y = ~convertedManaCost) %&gt;% add_lines(x = ~stats, y = fitted(fit)) %&gt;% layout(showlegend = F) %&gt;% layout(xaxis = list(title = &quot;Card Stats&quot;), yaxis = list(title = &quot;Mana Cost&quot;)) %&gt;% layout(title=&quot;Creature Stats vs Mana Cost Regression&quot;) fig #subsetting the data for creature cards # removing NA&#39;s #gouping by creature subtype and summarising mtg.1 &lt;- mtg %&gt;% filter(type == &#39;Creature&#39;) %&gt;% replace_na(list(toughness = 0, power = 0)) %&gt;% mutate(stats = power + toughness) %&gt;% select(stats, convertedManaCost, subtypes) %&gt;% group_by(subtypes) %&gt;% summarise_at(vars(stats:convertedManaCost), mean, na.rm = TRUE) # Initiating the interactive plot fig1 &lt;- plot_ly(data = mtg.1, x = ~stats, y = ~convertedManaCost, color = ~subtypes) # Adding title to the axis legend fig1 &lt;- fig1 %&gt;% layout(xaxis = list(title = &quot;Mean Creature Stats&quot;), yaxis = list(title = &quot;Mean Mana Cost&quot;)) # Adding title to plot, creating interactive markers for each point fig1 &lt;- fig1 %&gt;% layout(showlegend = FALSE, title=&#39;Mean Mana Cost and Stats by Subtype&#39;) %&gt;% add_markers(hoverinfo = &#39;text&#39;, text = ~paste(&#39;&lt;/br&gt; Subtype: &#39;, subtypes, &#39;&lt;/br&gt; Creature Stats: &#39;, stats, &#39;&lt;/br&gt; Mean Mana Cost: &#39;, convertedManaCost)) fig1 # Subsetting the data to show only creatures # Then groups by subtypes and total stats # Last, summarises the mean mana cost for each group mtg.2 &lt;- mtg %&gt;% filter(type == &#39;Creature&#39;) %&gt;% replace_na(list(toughness = 0, power = 0)) %&gt;% mutate(stats = power + toughness) %&gt;% select(stats, convertedManaCost, subtypes) %&gt;% group_by(subtypes, stats) %&gt;% summarise(meanManaCost = mean(convertedManaCost)) # Initiates the interactive plot fig2 &lt;- plot_ly(data = mtg.2, x = ~stats, y = ~meanManaCost, color = ~subtypes) # Adds title to the axes legend fig2 &lt;- fig2 %&gt;% layout(xaxis = list(title = &quot;Creature Stats&quot;), yaxis = list(title = &quot;Mean Mana Cost&quot;)) # Adss title to plot, then creates interactive markers for each point fig2 &lt;- fig2 %&gt;% layout(showlegend = FALSE, title=&#39;Mean Mana Cost by Creature Stats and Subtype&#39;) %&gt;% add_markers(hoverinfo = &#39;text&#39;, text = ~paste(&#39;&lt;/br&gt; Subtype: &#39;, subtypes, &#39;&lt;/br&gt; Creature Stats: &#39;, stats, &#39;&lt;/br&gt; Mean Mana Cost: &#39;, meanManaCost)) fig2 # reading the market data csv marketDf &lt;- read.csv(&#39;mtgMarketInfo.csv&#39;, header=TRUE) #removing the symbols and converting to numeric marketDf$Market.Price = as.numeric(gsub(&quot;\\\\$&quot;, &quot;&quot;, marketDf$Market.Price)) marketDf$Listed.Median = as.numeric(gsub(&quot;\\\\$&quot;, &quot;&quot;, marketDf$Listed.Median)) #stripping whitespace from strings marketDf$Rarity = gsub(&quot; &quot;, &quot;&quot;, marketDf$Rarity, fixed = TRUE) #filtering data to remove outliers marketDf1 &lt;- marketDf %&gt;% filter(Listed.Median &lt;= 50, Market.Price &lt;= 50) #plotting the data in ggplot p &lt;- ggplot( marketDf1, aes(x = Listed.Median, y = Market.Price, color = Rarity) ) + geom_point(show.legend = FALSE, alpha =0.7) + scale_color_viridis_d() + scale_size(range = c(1, 12)) + scale_x_log10() + labs(x = &quot;Listed Median Price&quot;, y=&quot;Market Price&quot;) + ggtitle(&#39;Market Price vs Listed Median Price by Set&#39;) #printing the static ggplot p #adding an animated transition for the plot in gganimate a &lt;- p + transition_states(Set.Name) + labs(title = &quot;Set: {closest_state}&quot;) #creating parameters and rendering the animation as GIF with gifski animate(a, fps = 3, width = 750, height = 450, renderer=gifski_renderer()) #subsetting the data and summarizing by grouped set and rarity marketDf2 &lt;- marketDf %&gt;% select(Set.Name, Rarity, Listed.Median) %&gt;% filter(Rarity==&quot;C&quot; | Rarity==&quot;U&quot; | Rarity==&quot;R&quot; | Rarity==&quot;M&quot;) %&gt;% na.omit() %&gt;% group_by(Set.Name,Rarity) %&gt;% summarise(mean.listed = mean(Listed.Median)) %&gt;% filter(mean.listed &lt;= 40) #creating bar chart in ggplot p&lt;-ggplot(data=marketDf2, aes(x=Rarity, y=mean.listed, fill=Rarity)) + geom_bar(stat=&quot;identity&quot;) + scale_fill_hue(c=45, l=80) + labs(title = &#39;Mean Card Value by Rarity and Set&#39;, y = &quot;Mean Listed Price&quot;) p #converting plot into animated timelapse(by set) a &lt;- p + transition_states(Set.Name) + labs(title= &quot;Set: {closest_state}&quot;) #rendering plot as a GIF animate(a, fps = 3, width = 750, height = 450, renderer=gifski_renderer()) "],["text-analysis.html", "Chapter 7 Text Analysis 7.1 Tidying the Text 7.2 All cards 7.3 Characteristic Words by Type 7.4 Characteristic Words by Subtype 7.5 Words and Prices", " Chapter 7 Text Analysis #READING IN THE DATA cmtg &lt;- read_csv(&quot;cleanData_New.csv&quot;, col_names = TRUE) cmtg &lt;- cmtg[,-1] ; cmtg &lt;- cmtg[,-4] # TOKENIZING SUBTYPES cmtg$subtypes &lt;- str_split(cmtg$subtypes, &quot;,&quot;) # TOKENIZING KEYWORDS cmtg$keywords &lt;- str_split(cmtg$keywords, &quot;,&quot;) # TURNING RARITY INTO A FACTOR cmtg$rarity &lt;- factor(cmtg$rarity, levels = c(&quot;common&quot;, &quot;uncommon&quot;, &quot;rare&quot;, &quot;mythic&quot;), ordered = TRUE) #FORMATTING POWER AND TOUGHNESS CORRECTLY # forces some to numeric, however upon investigation the cards turned to NA&#39;s are &#39;booster&#39; cards, which are like spell cards # these cards can be identified by their key words cmtg$power &lt;- as.numeric(cmtg$power) cmtg$toughness &lt;- as.numeric(cmtg$toughness) 7.1 Tidying the Text # PRE-PROCESSING # General cleaning text_mtg &lt;- distinct(cmtg, flavorText, .keep_all=TRUE) text_mtg$allText &lt;- paste(text_mtg$text, text_mtg$flavorText) text_mtg &lt;- text_mtg[, !(names(text_mtg) %in% c(&#39;flavorText&#39;, &#39;text&#39;))] text_mtg$allText &lt;- text_mtg$allText %&gt;% removeNumbers() %&gt;% str_replace_all(&quot;[^[:alnum:]]&quot;, &quot; &quot;) %&gt;% stri_trans_tolower() %&gt;% str_squish() # Handling type text_mtg$type &lt;- text_mtg$type %&gt;% removeNumbers() %&gt;% str_replace_all(&quot;[^[:alnum:]]&quot;, &quot; &quot;) %&gt;% stri_trans_tolower() %&gt;% str_squish() text_mtg &lt;- text_mtg %&gt;% mutate(type = str_remove_all(type, &quot;legendary |snow |world | ongoing |basic &quot;)) # Handling subtypes text_mtg &lt;- text_mtg %&gt;% unnest(subtypes) text_mtg$subtypes &lt;- text_mtg$subtypes %&gt;% str_replace_all(&quot;[^[:alnum:]]&quot;, &quot; &quot;) %&gt;% stri_trans_tolower() %&gt;% str_squish() text_mtg %&gt;% select(type, subtypes, allText) %&gt;% group_by(type, subtypes) %&gt;% mutate(word_count = n()) %&gt;% select(type, subtypes, word_count) %&gt;% distinct() %&gt;% ungroup() %&gt;% arrange(desc(word_count)) %&gt;% filter(word_count &gt; 100) %&gt;% kableFormat(&quot;Three Sources Stats&quot;) Table 3.1: Three Sources Stats type subtypes word_count instant NA 2177 creature human 1881 sorcery NA 1876 enchantment NA 981 artifact NA 802 enchantment aura 706 creature soldier 586 creature warrior 581 creature wizard 498 creature zombie 355 creature goblin 353 creature elf 344 creature cleric 332 creature elemental 325 creature spirit 324 land NA 321 creature shaman 294 creature beast 293 creature knight 282 creature rogue 216 creature bird 196 creature merfolk 195 creature vampire 183 creature druid 177 creature cat 161 creature insect 140 artifact equipment 133 creature scout 129 creature wall 128 creature giant 127 creature horror 125 creature dragon 123 creature angel 121 artifact creature construct 110 # ALL CARDS INFORMATION all_cards &lt;- text_mtg[23] %&gt;% summarise(allText = paste(allText, collapse = &quot;,&quot;)) # GROUPED BY TYPE COMBINATION # Identifying significant types n_occur_type &lt;- data.frame(table(text_mtg$type)) significant_types &lt;- n_occur_type %&gt;% filter(n_occur_type$Freq &gt; 50) %&gt;% select(Var1) type_cards &lt;- aggregate(allText ~ type, text_mtg[c(4, 23)],paste,collapse=&quot;&quot;) %&gt;% subset(type %in% as.vector(unlist(significant_types))) # GROUPED BY SUBTYPE # Identifying significant subtypes n_occur &lt;- data.frame(table(text_mtg$subtypes)) significant_subtypes &lt;- n_occur %&gt;% filter(n_occur$Freq &gt; 100) %&gt;% select(Var1) subtype_cards &lt;- aggregate(allText ~ subtypes, text_mtg[c(5, 23)],paste,collapse=&quot;&quot;) %&gt;% subset(subtypes %in% as.vector(unlist(significant_subtypes))) # REMOVING TEMPORARY VARIABLES FROM THE ENVIRONMENT remove(significant_subtypes, significant_types, n_occur, n_occur_type) # PREPARATION FUNCTION prepare_text &lt;- function(df){ df &lt;- df %&gt;% unnest_tokens(word,allText) df &lt;- df %&gt;% anti_join(stop_words) return(df) } 7.2 All cards all_cards_count &lt;- prepare_text(all_cards) %&gt;% mutate(word = lemmatize_words(word)) %&gt;% count(word,sort=TRUE) ## Joining, by = &quot;word&quot; # TEXT STATISTICS mean_use &lt;- mean(all_cards_count$n) median_use &lt;- median(all_cards_count$n) AllFreqBar &lt;- all_cards_count%&gt;% head(10)%&gt;% ggplot(mapping = aes(x = reorder(word,n), n, text = paste(&quot;Count:&quot;, n))) + geom_bar(stat = &quot;identity&quot;,fill=&quot;lightblue&quot;, alpha = 0.90) + labs(title = &quot;Top 10 Most Used Words on MTG Cards&quot;, x = &quot;&quot;, y = &quot;Frequency&quot;) + scale_y_continuous(breaks = pretty_breaks()) + coord_flip() + theme_bw() + theme(panel.grid.major.x = element_line(size = 1.25), axis.text.x = element_text(size = 12, face = &quot;bold&quot;), text=element_text(size=16, family=&quot;serif&quot;), axis.title.y = element_text(vjust=2), plot.title = element_text(hjust = 0.5), legend.position = &quot;none&quot;) + geom_hline(yintercept = mean_use, linetype=&quot;dotted&quot;, color = &quot;red&quot;, size=0.5) + geom_hline(yintercept = median_use, linetype=&quot;dotted&quot;, color = &quot;black&quot;, size=0.5) ggplotly(AllFreqBar, tooltip=&quot;text&quot;) # plot_gg(AllFreqBar, width=7, height=5, raytrace=TRUE, multicore=TRUE) all_cards_count %&gt;% head(100) %&gt;% e_charts() %&gt;% e_cloud(word, n, shape=&#39;square&#39;) %&gt;% e_title(&quot;Highest frequency words&quot;, &quot;All Magic the Gathering Cards&quot;) %&gt;% e_tooltip(trigger = &quot;item&quot;) %&gt;% e_theme(&quot;westeros&quot;) %&gt;% e_color(background=&#39;#edf4f5&#39;) 7.3 Characteristic Words by Type type_count &lt;- prepare_text(type_cards) %&gt;% mutate(word = lemmatize_words(word)) %&gt;% count(type, word,sort=TRUE) type_tf_idf &lt;- type_count %&gt;% bind_tf_idf(word, type, n) %&gt;% group_by(type)%&gt;% select(-n)%&gt;% arrange(desc(tf_idf)) type_tf_idf_plot &lt;- type_tf_idf %&gt;% group_by(type) %&gt;% slice_max(tf_idf, n = 10) %&gt;% ungroup() %&gt;% ggplot(aes(tf_idf, fct_reorder(word, tf_idf), fill = type)) + geom_col(show.legend = FALSE) + facet_wrap(~type, ncol = 1, scales = &quot;free&quot;) + labs(title = &quot;TF-IDF Results by Type&quot;, x = &quot;tf-idf&quot;, y = NULL) + theme(axis.titleaxis.text=element_text(size=20), axis.title=element_text(size=14,face=&quot;bold&quot;), plot.title = element_text(hjust = 0.5, vjust=10)) + theme_bw() type_tf_idf_plot 7.4 Characteristic Words by Subtype subtype_count &lt;- prepare_text(subtype_cards) %&gt;% mutate(word = lemmatize_words(word)) %&gt;% count(subtypes, word,sort=TRUE) ## Joining, by = &quot;word&quot; subtype_tf_idf &lt;- subtype_count %&gt;% bind_tf_idf(word, subtypes, n) %&gt;% group_by(subtypes)%&gt;% select(-n)%&gt;% arrange(desc(tf_idf)) mycolors &lt;- colorRampPalette(brewer.pal(8, &quot;Set2&quot;))(30) subtype_tf_idf %&gt;% group_by(subtypes) %&gt;% slice_max(tf_idf, n = 10) %&gt;% ungroup() %&gt;% ggplot(aes(tf_idf, fct_reorder(word, tf_idf), fill = subtypes)) + geom_col(show.legend = FALSE) + facet_wrap(~subtypes, ncol = 1, scales = &quot;free&quot;) + scale_fill_manual(values = mycolors) + labs(title=&quot;TF-IDF Report for Subtypes&quot;, subtitle = &quot;&quot;, x = &quot;tf-id valuef&quot;, y = NULL) + theme(axis.text=element_text(size=10), axis.title=element_text(size=14,face=&quot;bold&quot;)) 7.5 Words and Prices word_price &lt;- text_mtg[19:23] %&gt;% summarise(allText = allText, meanPrice = rowMeans(text_mtg[,19:22])) word_price_count &lt;- prepare_text(word_price) %&gt;% group_by(word) %&gt;% filter(n()&gt;5) %&gt;% summarise(mean_price_word = mean(meanPrice)) ## Joining, by = &quot;word&quot; ## `summarise()` ungrouping output (override with `.groups` argument) word_price_count%&gt;% arrange(desc((mean_price_word))) %&gt;% head(10) %&gt;% kableFormat(&quot;Words Associated with Greatest Mean Cost&quot;) Table 7.1: Words Associated with Greatest Mean Cost word mean_price_word joining 114.66682 parents 114.40149 explore 113.85063 brother 80.40931 ccc 77.14685 sneak 62.74305 de 53.62400 tocasia 50.36793 seedling 45.01387 clarity 41.77917 word_price_count%&gt;% arrange((mean_price_word)) %&gt;% head(10) %&gt;% kableFormat(&quot;Words Associated with Lowest Mean Cost&quot;) Table 7.1: Words Associated with Lowest Mean Cost word mean_price_word american 0.0000000 asia 0.0000000 european 0.0000000 fc 0.0000000 championship 0.0075000 riverlands 0.0130357 chao 0.0132246 jiang 0.0227500 bureaucrats 0.0230901 skirmisher 0.0233333 mean(word_price_count$mean_price_word) ## [1] 1.296415 "],["discussion.html", "Chapter 8 Discussion 8.1 Future Directions 8.2 What We Learned Along the Way", " Chapter 8 Discussion 8.1 Future Directions The results of the exploratory data analysis imply that topic modeling (LDA; Latent Derelict Allocation) would be fruitful, if only just to satisfy curiosity. 8.2 What We Learned Along the Way Kevin In terms of data analysis methods, this project has contributed substantially to my understanding of Plotly functionality, interactive plot production, and general good practices for displaying data in an accessible/readable way. Prior to generating these Magic the Gathering plots, I had little to no experience in creating interactive figures, but am now comfortable making box plots, histograms, and 3D scatter plots with hover-text and zooming options, and I am sure these new skills will translate well to numerous other projects and plot types. As for what I learned from the data, I can safely tell you that Magic the Gathering has a massive amount of cards that are mostly cheap and expendable, but some that are so expensive you might want to reevaluate your life if you are considering purchasing them. There was substantial variability in the card prices, leading to some terribly low correlations between price and most other card attributes. However, I did find some interesting info about about average card price by artist (apparently April Lee and a couple other artists are producing art for some extraordinarily valuable cards). I also learned that (surprise, surprise!) mana cost correlates pretty directly with other card attributes, like power and toughness. I also confirmed my suspicion that rare and mythic cards have a tendency to be a bit pricier than common and uncommon. Sara I gained an incredible amount of respect for anyone who has ever knit a Bookdown which complies code from multiple authors. Other than my near-defeat at the hands of Knitr, this was a very enjoyable project. It was less focused than my last project for this class, which turned into a small report, but that allowed us more creativity with how we explored the data and let us explore the data in more thorough detail. Rather than simply producing a single plot and crying - Look! Demographics - our group looked at most every aspect of the data which seemed significant. I was also able to mess around with text data, which I havent been able to do in a while, which was fun. I did not have the time to preform topic modeling, which I wanted to, because we were short on time, but I suppose Ill have to wait until Machine Learning to scratch that itch. Regardless, I did a lot of munging with the data for this project and it was fun because I quite like problem solving and thats what munging distills down to. I also enjoyed playing around with plotly and the raytracer packages - though our raytraced graphic is perhaps not the best use of the raytracer. I knew absolutely nothing about Magic the Gathering coming into this project, and am happy to have learned something about what is apparently a quite lucrative card game while investigating data on it. My contributions to the project were aiding in the project direction, gathering the cards data, cleaning and combining the cards and 2019 market data, completing the text analysis portion, completing the data quality portion, assisting with the write-ups, taking point on arranging group meetings, and putting together the Bookdown. This is the first time Ive made a Bookdown alone, which Im pretty, to be colloquial, hype about. Conor This project was so enjoyable for me, for many reasons. I have had an interest in card games ever since the 90s when Pokemon infiltrated the minds of every child in America. Magic: The Gathering is a game I have enjoyed for a number of years, and getting the opportunity to explore it deeper through heaps of data with the aid of some of my hard-working peers has been a great experience. I have not only learned a lot about the cards data, but have expanded my knowledge on data visualization techniques and had the opportunity to think critically about the most effective methods for conveying my findings to others. Interactive plots and animated/timelapse plots are a new tool that I will surely be excited to utilize throughout my future data science academia and career. Miles I had played Magic the Gathering when I was younger and I found it fascinating to see how the card game I remembered could have such a following that it generates market data. I was not entirely surprised that a majority of the cards were in the lower price range, however, I was certainly surprised by how much someone would be willing to pay for a piece of paper or, more surprisingly, some bytes. One thing that I found personally interesting was how we could see the foil variant of the cards appearing and becoming popular. I remember witnessing that while it was happening and being able to see it in the data felt rewarding. This was the first opportunity that I had to unpack and work with data in JSON format. I marveled at the amount of information that can be stored in deeper and deeper levels and I gained some knowledge on manipulating that data and how to stick it together. I found that I was much more successful with this manipulation in Python instead of R but I really began to enjoy manipulating the data and creating visualization in R. It is great to be able to create informative, aesthetically pleasing, and even interactive plots and the visualization that came from my group impressed me. "]]
